using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using System.Xml.Linq;
using OssSecurityAgent.Models;
using Microsoft.Extensions.AI;
using Octokit;

public class VulnerabilityRemediationService
{
    private readonly string _repoPath;
    private readonly string _githubToken;
    private readonly string _githubRepoUrl;
    private readonly List<string> _reviewers;
    private readonly IChatClient? _openAiClient;
    private readonly GitHubClient _gitHubClient;
    private string? _cachedOwner;
    private string? _cachedRepo;

    public VulnerabilityRemediationService(
        string repoPath,
        string githubToken,
        string githubRepoUrl,
        List<string> reviewers,
        IChatClient? openAiClient = null)
    {
        _repoPath = repoPath ?? throw new ArgumentNullException(nameof(repoPath));
        _githubToken = githubToken ?? throw new ArgumentNullException(nameof(githubToken));
        _githubRepoUrl = githubRepoUrl ?? throw new ArgumentNullException(nameof(githubRepoUrl));
        _reviewers = reviewers ?? new();
        _openAiClient = openAiClient;
        _gitHubClient = new GitHubClient(new ProductHeaderValue("OssSecurityAgent"))
        {
            Credentials = new Credentials(githubToken)
        };
    }

    public async Task<RemediationResult> ProcessVulnerabilitiesAsync(
        string vulnerabilityJson,
        DependencyGraph dependencyGraph)
    {
        var result = new RemediationResult();

        try
        {
            var vulnerabilities = ParseVulnerabilities(vulnerabilityJson);
            if (!vulnerabilities.Any())
            {
                result.Success = true;
                result.Message = "No vulnerabilities found";
                return result;
            }

            var prioritized = PrioritizeVulnerabilities(vulnerabilities);
            result.TotalVulnerabilities = prioritized.Count;

            foreach (var vulnerability in prioritized)
            {
                var remediationItem = new RemediationItem
                {
                    Vulnerability = vulnerability,
                    PackageKey = $"{vulnerability.PackageName}@{vulnerability.CurrentVersion}"
                };

                try
                {
                    // Filter by CVSS score
                    if (vulnerability.CvssScore.HasValue && vulnerability.CvssScore < 5.0)
                    {
                        remediationItem.Status = "skipped-low-priority";
                        remediationItem.Notes = $"CVSS {vulnerability.CvssScore} - Low priority";
                        result.Items.Add(remediationItem);
                        continue;
                    }

                    // Get all packages to update (root + entire dependency tree)
                    var packagesToUpdate = new List<Vulnerability> { vulnerability };
                    var allDependents = GetAllTransitiveDependents(
                        vulnerability.PackageName,
                        vulnerability.CurrentVersion,
                        dependencyGraph,
                        new HashSet<string>());

                    foreach (var dependentKey in allDependents)
                    {
                        var parts = dependentKey.Split("@");
                        if (parts.Length == 2)
                        {
                            var dependentVuln = vulnerabilities.FirstOrDefault(v =>
                                v.PackageName == parts[0] && v.CurrentVersion == parts[1]);
                            if (dependentVuln != null && dependentVuln.FixedVersion != null)
                            {
                                if (!packagesToUpdate.Any(p => p.PackageName == dependentVuln.PackageName && p.CurrentVersion == dependentVuln.CurrentVersion))
                                    packagesToUpdate.Add(dependentVuln);
                            }
                        }
                    }

                    remediationItem.CascadeUpdates = packagesToUpdate.Count - 1;

                    // Create feature branch and push to GitHub
                    var branchName = CreateGitHubBranchName(vulnerability);
                    remediationItem.BranchName = branchName;

                    // Perform git operations
                    var gitOps = new GitOperations(_repoPath);
                    var (branchCreated, branchOutput) = await gitOps.CreateBranchAsync(branchName);
                    if (!branchCreated)
                    {
                        throw new Exception($"Failed to create branch {branchName}: {branchOutput}");
                    }

                    // Update all packages
                    var updateSuccess = await UpdateProjectDependenciesAsync(packagesToUpdate);
                    remediationItem.DependencyUpdateSuccess = updateSuccess;

                    if (!updateSuccess)
                    {
                        throw new Exception("Failed to update project dependencies");
                    }

                    // Run build validation BEFORE committing
                    // This ensures any repairs (like enabling ImplicitUsings) are included in the PR
                    BuildResult? buildResult = null;
                    bool repairsWereApplied = false;
                    
                    if (_openAiClient != null)
                    {
                        var validator = new BuildValidator(_repoPath, _openAiClient);
                        buildResult = await validator.ValidateAndRepairAsync();
                        remediationItem.BuildValidationSuccess = buildResult.Success;
                        remediationItem.BuildErrorSummary = buildResult.ErrorSummary;
                        
                        // Check if any repairs were attempted (more than one iteration means repairs were applied)
                        repairsWereApplied = buildResult.Iterations.Any(it => !string.IsNullOrEmpty(it.AppliedFix));
                        
                        // If repairs were made, stage and commit them
                        if (repairsWereApplied)
                        {
                            var (repairAddSuccess, repairAddOutput) = await gitOps.AddChangesAsync(".");
                            if (repairAddSuccess)
                            {
                                var repairSummary = string.Join("\n", 
                                    buildResult.Iterations
                                        .Where(it => !string.IsNullOrEmpty(it.AppliedFix))
                                        .Select(it => $"- {it.Strategy}: {it.AppliedFix}"));
                                
                                var repairCommitMsg = $"chore: Apply build repairs\n\nApplied fixes:\n{repairSummary}";
                                var (repairCommitSuccess, repairCommitOutput) = await gitOps.CommitAsync(repairCommitMsg);
                                if (!repairCommitSuccess)
                                {
                                    Console.WriteLine($"Warning: Could not commit repair changes: {repairCommitOutput}");
                                }
                            }
                        }
                    }

                    // Add and commit changes
                    var (addSuccess, addOutput) = await gitOps.AddChangesAsync(".");
                    if (!addSuccess)
                    {
                        throw new Exception($"Failed to add changes: {addOutput}");
                    }

                    var commitMessage = $"Security fix: Upgrade {vulnerability.PackageName} to {vulnerability.FixedVersion}\n\nCVSS: {vulnerability.CvssScore}\nVulnerability: {vulnerability.CVE}";
                    var (commitSuccess, commitOutput) = await gitOps.CommitAsync(commitMessage);
                    if (!commitSuccess)
                    {
                        throw new Exception($"Failed to commit changes: {commitOutput}");
                    }

                    // Push branch to GitHub (now includes any repair commits)
                    var (pushSuccess, pushOutput) = await gitOps.PushBranchAsync(branchName);
                    if (!pushSuccess)
                    {
                        throw new Exception($"Failed to push branch {branchName} to GitHub: {pushOutput}");
                    }

                    // Try to create GitHub issue and PR together
                    string? issueUrl = null;
                    string? issueNumber = null;
                    
                    try
                    {
                        issueUrl = await CreateGitHubIssueAsync(vulnerability, packagesToUpdate);
                        
                        if (!string.IsNullOrEmpty(issueUrl))
                        {
                            remediationItem.GitHubIssueUrl = issueUrl;
                            
                            // Extract issue number for linking in PR
                            var issueMatch = System.Text.RegularExpressions.Regex.Match(issueUrl, @"/issues/(\d+)$");
                            if (issueMatch.Success)
                                issueNumber = issueMatch.Groups[1].Value;
                        }
                    }
                    catch (Exception issueEx)
                    {
                        Console.WriteLine($"Note: Issue creation failed, attempting PR without issue link: {issueEx.Message}");
                    }

                    // Create PR with reference to issue (if issue was created)
                    var prUrl = await CreateGitHubPullRequestAsync(vulnerability, branchName, packagesToUpdate, issueNumber ?? "");
                    
                    if (string.IsNullOrEmpty(prUrl))
                    {
                        throw new Exception("Failed to create GitHub PR");
                    }

                    remediationItem.GitHubPullRequestUrl = prUrl;
                    
                    // Link issue back to PR if both exist
                    if (!string.IsNullOrEmpty(issueUrl) && !string.IsNullOrEmpty(prUrl))
                    {
                        try
                        {
                            // Extract issue number from URL if issueNumber is not set
                            var actualIssueNumber = issueNumber;
                            if (string.IsNullOrEmpty(actualIssueNumber))
                            {
                                var issueMatch = System.Text.RegularExpressions.Regex.Match(issueUrl, @"/issues/(\d+)$");
                                if (issueMatch.Success)
                                {
                                    actualIssueNumber = issueMatch.Groups[1].Value;
                                }
                            }
                            
                            var prMatch = System.Text.RegularExpressions.Regex.Match(prUrl, @"/pull/(\d+)$");
                            if (prMatch.Success && !string.IsNullOrEmpty(actualIssueNumber))
                            {
                                var prNumber = prMatch.Groups[1].Value;
                                await LinkIssueToPublicAsync(actualIssueNumber, prNumber);
                            }
                        }
                        catch (Exception linkEx)
                        {
                            Console.WriteLine($"Note: Could not link issue to PR: {linkEx.Message}");
                        }
                    }

                    // Request reviews
                    if (!string.IsNullOrEmpty(prUrl))
                    {
                        await RequestReviewersAsync(prUrl);
                        remediationItem.ReviewersRequested = new List<string>(_reviewers);
                    }

                    // Handle build failures
                    if (buildResult != null && !buildResult.Success)
                    {
                        await CommentOnPullRequestAsync(prUrl,
                            GenerateBuildFailureComment(buildResult));
                        remediationItem.Status = "build-failed-pr-open-for-review";
                    }
                    else
                    {
                        remediationItem.Status = "remediation-created";
                    }

                    remediationItem.Success = true;
                }
                catch (Exception ex)
                {
                    remediationItem.Status = "failed";
                    remediationItem.Error = ex.Message;
                    remediationItem.Success = false;
                }

                result.Items.Add(remediationItem);
            }

            result.Success = result.Items.All(i => i.Success || i.Status == "skipped-low-priority");
            result.SuccessfulRemediations = result.Items.Count(i => i.Success);
            result.FailedRemediations = result.Items.Count(i => !i.Success && i.Status != "skipped-low-priority");
            var skippedRemediations = result.Items.Count(i => i.Status == "skipped-low-priority");
            result.Message = $"Created {result.SuccessfulRemediations} PRs, {result.FailedRemediations} failed, {skippedRemediations} skipped";

            return result;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.Error = ex.Message;
            return result;
        }
    }

    private List<string> GetAllTransitiveDependents(
        string packageName,
        string version,
        DependencyGraph dependencyGraph,
        HashSet<string> visited)
    {
        var allDependents = new List<string>();
        var directDependents = dependencyGraph.GetDirectDependents(packageName, version);

        foreach (var dependent in directDependents)
        {
            if (visited.Contains(dependent))
                continue;

            visited.Add(dependent);
            allDependents.Add(dependent);

            var parts = dependent.Split("@");
            if (parts.Length == 2)
            {
                var transitiveDependents = GetAllTransitiveDependents(parts[0], parts[1], dependencyGraph, visited);
                allDependents.AddRange(transitiveDependents);
            }
        }

        return allDependents;
    }

    private List<Vulnerability> ParseVulnerabilities(string vulnerabilityJson)
    {
        var vulnerabilities = new List<Vulnerability>();

        try
        {
            using var doc = JsonDocument.Parse(vulnerabilityJson);
            var root = doc.RootElement;

            foreach (var packageElement in root.EnumerateObject())
            {
                var parts = packageElement.Name.Split("@");
                if (parts.Length != 2) continue;

                var packageName = parts[0];
                var currentVersion = parts[1];

                // Handle two possible JSON structures:
                // 1. Simple array: {"package@version": [{vuln_objects}]}
                // 2. Complex object: {"package@version": {vulnerabilities: [{vuln_objects}]}}
                
                JsonElement vulnsArray = default;
                bool foundVulnerabilities = false;

                if (packageElement.Value.ValueKind == JsonValueKind.Array)
                {
                    // Structure 1: Direct array of vulnerabilities
                    vulnsArray = packageElement.Value;
                    foundVulnerabilities = true;
                }
                else if (packageElement.Value.ValueKind == JsonValueKind.Object)
                {
                    // Structure 2: Object with vulnerabilities property
                    if (packageElement.Value.TryGetProperty("vulnerabilities", out var vulnsElement) &&
                        vulnsElement.ValueKind == JsonValueKind.Array)
                    {
                        vulnsArray = vulnsElement;
                        foundVulnerabilities = true;
                    }
                    // Also check for "vulns" property as fallback
                    else if (packageElement.Value.TryGetProperty("vulns", out vulnsElement) &&
                             vulnsElement.ValueKind == JsonValueKind.Array)
                    {
                        vulnsArray = vulnsElement;
                        foundVulnerabilities = true;
                    }
                }

                if (foundVulnerabilities && vulnsArray.ValueKind == JsonValueKind.Array)
                {
                    foreach (var vulnElement in vulnsArray.EnumerateArray())
                    {
                        var vuln = new Vulnerability { PackageName = packageName, CurrentVersion = currentVersion };

                        if (vulnElement.TryGetProperty("id", out var idProp))
                            vuln.Id = idProp.GetString();
                        if (vulnElement.TryGetProperty("summary", out var summaryProp))
                            vuln.Description = summaryProp.GetString();
                        if (vulnElement.TryGetProperty("cve", out var cveProp))
                            vuln.CVE = cveProp.GetString();
                        
                        // Handle score (could be "score" or "cvss_score" or similar)
                        if (vulnElement.TryGetProperty("score", out var scoreProp) &&
                            scoreProp.TryGetDouble(out var score))
                        {
                            vuln.CvssScore = score;
                        }
                        
                        // Get fixed version from "fixed_in" array
                        if (vulnElement.TryGetProperty("fixed_in", out var fixedInProp) &&
                            fixedInProp.ValueKind == JsonValueKind.Array &&
                            fixedInProp.GetArrayLength() > 0)
                        {
                            var firstFixed = fixedInProp[0];
                            if (firstFixed.ValueKind == JsonValueKind.String)
                                vuln.FixedVersion = firstFixed.GetString();
                        }
                        // Also check for "fixed_version" property
                        else if (vulnElement.TryGetProperty("fixed_version", out var fixedProp))
                            vuln.FixedVersion = fixedProp.GetString();

                        vulnerabilities.Add(vuln);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            // Silently fail - return empty list if parsing fails
        }

        return vulnerabilities;
    }


    private List<Vulnerability> PrioritizeVulnerabilities(List<Vulnerability> vulnerabilities) =>
        vulnerabilities.OrderByDescending(v => v.CvssScore ?? 0).ToList();

    private string CreateGitHubBranchName(Vulnerability vulnerability)
    {
        var sanitized = vulnerability.PackageName.Replace(".", "-").ToLower();
        var timestamp = DateTime.UtcNow.ToString("ddMMyyyyHHmmss");
        return $"infosec-fix-{sanitized}-{vulnerability.CurrentVersion}-{timestamp}";
    }

    private async Task<string?> CreateGitHubIssueAsync(Vulnerability vulnerability, List<Vulnerability> allUpdates)
    {
        try
        {
            var (owner, repo) = GetRepositoryInfo();
            
            var title = $"[SECURITY] Update {vulnerability.PackageName} to {vulnerability.FixedVersion} - {vulnerability.CVE ?? "Vulnerability"}";
            var updatesSection = string.Join("\n", allUpdates.Select(v =>
                $"- **{v.PackageName}**: {v.CurrentVersion} ‚Üí {v.FixedVersion ?? "latest"}"));

            var body = $@"## Security Vulnerability Report

**Root Package:** {vulnerability.PackageName}
**Current Version:** {vulnerability.CurrentVersion}
**Fixed Version:** {vulnerability.FixedVersion ?? "Check NuGet"}
**Severity:** {(vulnerability.CvssScore.HasValue ? $"CVSS {Math.Round(vulnerability.CvssScore.Value, 1)}" : "Unknown")}
**CVE:** {vulnerability.CVE ?? "N/A"}

### Description
{vulnerability.Description ?? "Security vulnerability detected in dependency"}

### Packages to Update
{updatesSection}

### Status
üîÑ Automated remediation in progress

---
*Auto-generated by OssSecurityAgent*";

            var newIssue = new NewIssue(title) { Body = body };
            if (newIssue.Labels != null)
            {
                newIssue.Labels.Add("security");
                newIssue.Labels.Add("automated");
            }

            try
            {
                var issue = await _gitHubClient.Issue.Create(owner, repo, newIssue);
                return issue.HtmlUrl;
            }
            catch (OverflowException ex)
            {
                // Octokit bug: Int32 overflow on GitHub's Int64 fields
                // Issue was created but Octokit can't deserialize response
                // Query GitHub API directly to find the created issue
                Console.WriteLine($"  Attempting to recover from OverflowException by querying GitHub API...");
                try
                {
                    // Wait a moment for the issue to be fully created
                    await Task.Delay(500);
                    
                    using var httpClient = new System.Net.Http.HttpClient();
                    httpClient.DefaultRequestHeaders.Add("User-Agent", "OssSecurityAgent");
                    if (!string.IsNullOrEmpty(_githubToken))
                    {
                        httpClient.DefaultRequestHeaders.Authorization =
                            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _githubToken);
                    }
                    else
                    {
                        Console.WriteLine("  Warning: GitHub token not available for REST fallback; proceeding unauthenticated.");
                    }
                    
                    var requestUrl = $"https://api.github.com/repos/{owner}/{repo}/issues?state=all&sort=created&direction=desc&per_page=10";
                    Console.WriteLine($"  Querying: {requestUrl}");
                    
                    var response = await httpClient.GetAsync(requestUrl);
                    Console.WriteLine($"  Response: {response.StatusCode}");
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var jsonContent = await response.Content.ReadAsStringAsync();
                        Console.WriteLine($"  Found {(jsonContent.Length > 100 ? "content" : "empty response")}");
                        
                        using var doc = JsonDocument.Parse(jsonContent);
                        var root = doc.RootElement;
                        
                        Console.WriteLine($"  Searching {root.GetArrayLength()} issues for title: {title}");
                        foreach (var issue in root.EnumerateArray().Where(i => i.TryGetProperty("title", out _)))
                        {
                            var issueTitle = issue.GetProperty("title").GetString();
                            Console.WriteLine($"    Checking: {issueTitle}");
                            if (issueTitle == title && issue.TryGetProperty("html_url", out var urlElem))
                            {
                                var issueUrl = urlElem.GetString();
                                Console.WriteLine($"‚úì Issue created (recovered from Octokit deserialization error): {issueUrl}");
                                return issueUrl;
                            }
                        }
                        Console.WriteLine($"  No matching issue found in API response");
                    }
                    else
                    {
                        Console.WriteLine($"  API returned: {response.StatusCode}");
                    }
                }
                catch (Exception fallbackEx)
                {
                    Console.WriteLine($"  Fallback error: {fallbackEx.GetType().Name}: {fallbackEx.Message}");
                }
                
                // If we can't find it, return null but log that creation likely succeeded
                Console.WriteLine($"Note: Issue likely created but response parsing failed (Octokit Int64 deserialization issue)");
                return null;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Note: Unable to create issue: {ex.Message}");
            Console.WriteLine($"Exception Type: {ex.GetType().FullName}");
            if (!string.IsNullOrEmpty(ex.StackTrace))
            {
                var lines = ex.StackTrace.Split('\n');
                foreach (var line in lines.Take(3))
                {
                    Console.WriteLine($"  {line}");
                }
            }
            return null;
        }
    }

    private async Task<bool> UpdateProjectDependenciesAsync(List<Vulnerability> vulnerabilities)
    {
        try
        {
            var csprojFiles = Directory.GetFiles(_repoPath, "*.csproj", SearchOption.AllDirectories);

            foreach (var csprojPath in csprojFiles)
            {
                var doc = XDocument.Load(csprojPath);
                var root = doc.Root;
                if (root == null) continue;

                foreach (var vuln in vulnerabilities)
                {
                    var packageRefs = root.Descendants("PackageReference")
                        .Where(pr => pr.Attribute("Include")?.Value == vuln.PackageName)
                        .ToList();

                    foreach (var pkgRef in packageRefs)
                    {
                        if (!string.IsNullOrEmpty(vuln.FixedVersion))
                        {
                            var versionAttr = pkgRef.Attribute("Version");
                            if (versionAttr != null)
                                versionAttr.Value = vuln.FixedVersion;
                            else
                                pkgRef.SetAttributeValue("Version", vuln.FixedVersion);
                        }
                    }
                }

                doc.Save(csprojPath);
            }

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating dependencies: {ex.Message}");
            return false;
        }
    }

    private async Task<string?> CreateGitHubPullRequestAsync(Vulnerability vulnerability, string branchName, List<Vulnerability> updates, string issueNumber = "")
    {
        try
        {
            var (owner, repo) = GetRepositoryInfo();
            
            var updatesMarkdown = string.Join("\n", updates.Select(v =>
                $"- {v.PackageName}: {v.CurrentVersion} to {v.FixedVersion}"));

            var issueLink = string.IsNullOrEmpty(issueNumber) ? "" : $"\nCloses #{issueNumber}";
            var body = $@"## Security Fix: {vulnerability.PackageName}

Resolves {vulnerability.CVE ?? "security vulnerability"} in {vulnerability.PackageName}

**CVSS Score:** {vulnerability.CvssScore ?? 0}
**Current Version:** {vulnerability.CurrentVersion}
**Fixed Version:** {vulnerability.FixedVersion}
**Branch:** {branchName}

### Vulnerabilities Addressed
{updatesMarkdown}

### Changes Made
- Updated {vulnerability.PackageName} to {vulnerability.FixedVersion}
- All transitive dependencies updated accordingly

### Testing
- Build validation executed
- Awaiting CI/CD checks
- Awaiting approval and merge

---
*Automated security remediation PR - Created by OssSecurityAgent*{issueLink}";

            var newPr = new NewPullRequest($"Security fix: Upgrade {vulnerability.PackageName} to {vulnerability.FixedVersion}", branchName, "main")
            {
                Body = body
            };

            var pr = await _gitHubClient.PullRequest.Create(owner, repo, newPr);
            
            // Add security-fix label for merge automation
            try
            {
                await _gitHubClient.Issue.Labels.AddToIssue(owner, repo, pr.Number, new[] { "security-fix" });
                Console.WriteLine($"‚úì Added 'security-fix' label to PR #{pr.Number}");
            }
            catch (Exception labelEx)
            {
                Console.WriteLine($"Note: Could not add 'security-fix' label to PR: {labelEx.Message}");
            }
            
            return pr.HtmlUrl;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating PR: {ex.Message}");
            Console.WriteLine($"Exception Type: {ex.GetType().Name}");
            if (ex.InnerException != null)
                Console.WriteLine($"  Inner error: {ex.InnerException.Message}");
            Console.WriteLine($"  Stack: {ex.StackTrace?.Substring(0, Math.Min(200, ex.StackTrace?.Length ?? 0))}");
            return null;
        }
    }

    private async Task LinkIssueToPublicAsync(string issueNumber, string prNumber)
    {
        if (string.IsNullOrEmpty(issueNumber) || string.IsNullOrEmpty(prNumber))
            return;

        try
        {
            var (owner, repo) = GetRepositoryInfo();
            
            // Try using Octokit first (works for small issue numbers)
            try
            {
                var comment = $"üîó **Related PR:** #{prNumber}\n\nThis issue is being addressed by pull request #{prNumber}. Once the PR is approved and merged, this issue will be automatically closed.";
                await _gitHubClient.Issue.Comment.Create(owner, repo, int.Parse(issueNumber), comment);
                Console.WriteLine($"‚úì Linked issue #{issueNumber} to PR #{prNumber}");
                return;
            }
            catch (OverflowException)
            {
                // Issue number is too large for Int32, use GitHub API directly
                Console.WriteLine($"  Using GitHub API directly to comment on issue (Int64 issue)...");
            }
            
            // Fallback: Use GitHub API directly for large issue numbers
            using var httpClient = new System.Net.Http.HttpClient();
            httpClient.DefaultRequestHeaders.Add("User-Agent", "OssSecurityAgent");
            httpClient.DefaultRequestHeaders.Authorization = 
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _githubToken);
            
            var comment_text = $"üîó **Related PR:** #{prNumber}\n\nThis issue is being addressed by pull request #{prNumber}. Once the PR is approved and merged, this issue will be automatically closed.";
            var jsonPayload = System.Text.Json.JsonSerializer.Serialize(new { body = comment_text });
            
            using var content = new System.Net.Http.StringContent(jsonPayload, System.Text.Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync(
                $"https://api.github.com/repos/{owner}/{repo}/issues/{issueNumber}/comments",
                content);
            
            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine($"‚úì Linked issue #{issueNumber} to PR #{prNumber}");
            }
            else
            {
                Console.WriteLine($"Note: Failed to add linking comment: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Note: Could not add linking comment to issue: {ex.Message}");
        }
    }

    private (string owner, string repo) GetRepositoryInfo()
    {
        // If already cached, return cached values
        if (!string.IsNullOrEmpty(_cachedOwner) && !string.IsNullOrEmpty(_cachedRepo))
        {
            return (_cachedOwner, _cachedRepo);
        }

        // Parse GitHub URL: https://github.com/owner/repo or https://github.com/owner/repo.git
        var match = System.Text.RegularExpressions.Regex.Match(_githubRepoUrl, @"github\.com[:/]([^/]+)/([^/]+?)(?:\.git)?/?$", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        if (!match.Success)
        {
            throw new InvalidOperationException($"Invalid GitHub URL format: {_githubRepoUrl}");
        }

        _cachedOwner = match.Groups[1].Value;
        _cachedRepo = match.Groups[2].Value;
        
        Console.WriteLine($"üìç Parsed GitHub repo: {_cachedOwner}/{_cachedRepo}");

        return (_cachedOwner, _cachedRepo);
    }

    private async Task RequestReviewersAsync(string prUrl)
    {
        try
        {
            if (!_reviewers.Any() || string.IsNullOrEmpty(prUrl))
                return;

            // Extract PR number from URL: https://github.com/owner/repo/pull/123
            var prMatch = System.Text.RegularExpressions.Regex.Match(prUrl, @"/pull/(\d+)$");
            if (!prMatch.Success)
                return;

            var prNumber = int.Parse(prMatch.Groups[1].Value);
            var (owner, repo) = GetRepositoryInfo();

            // Filter out the current user (can't request review from author)
            var validReviewers = _reviewers.Where(r => !r.Equals("rohitrajagarwal", StringComparison.OrdinalIgnoreCase)).ToList();
            
            if (!validReviewers.Any())
            {
                Console.WriteLine($"‚ö†Ô∏è  No other reviewers to request (author cannot review own PR)");
                return;
            }

            var reviewRequest = new PullRequestReviewRequest(
                reviewers: validReviewers,
                teamReviewers: new List<string>()
            );
            await _gitHubClient.PullRequest.ReviewRequest.Create(owner, repo, prNumber, reviewRequest);
            
            Console.WriteLine($"üìã Requested reviews from: {string.Join(", ", validReviewers)}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Note: Unable to request reviewers: {ex.Message}");
        }
    }

    private async Task CommentOnPullRequestAsync(string? prUrl, string comment)
    {
        try
        {
            if (string.IsNullOrEmpty(prUrl) || string.IsNullOrEmpty(comment))
                return;

            // Extract PR number from URL: https://github.com/owner/repo/pull/123
            var prMatch = System.Text.RegularExpressions.Regex.Match(prUrl, @"/pull/(\d+)$");
            if (!prMatch.Success)
                return;

            var prNumber = int.Parse(prMatch.Groups[1].Value);
            var (owner, repo) = GetRepositoryInfo();

            await _gitHubClient.Issue.Comment.Create(owner, repo, prNumber, comment);
            Console.WriteLine($"üí¨ Commented on PR #{prNumber}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Note: Unable to comment on PR: {ex.Message}");
        }
    }

    private string GenerateBuildFailureComment(BuildResult buildResult)
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("## ‚ö†Ô∏è Build Validation Failed");
        sb.AppendLine();
        sb.AppendLine("### Error Summary");
        sb.AppendLine(buildResult.ErrorSummary ?? "Unknown error");
        sb.AppendLine();
        sb.AppendLine("### Iteration Attempts");

        foreach (var iter in buildResult.Iterations)
        {
            sb.AppendLine($"- **Attempt {iter.AttemptNumber}** ({iter.Strategy}): {(iter.Success ? "‚úÖ Success" : "‚ùå Failed")}");
            if (!string.IsNullOrEmpty(iter.AppliedFix))
                sb.AppendLine($"  - Applied: {iter.AppliedFix}");
        }

        sb.AppendLine();
        sb.AppendLine("### Action Required");
        sb.AppendLine("Build validation failed after 3 automated recovery attempts.");
        sb.AppendLine("Please review the error summary and resolve manually.");

        return sb.ToString();
    }
}

public class RemediationResult
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public string? Error { get; set; }
    public int TotalVulnerabilities { get; set; }
    public int SuccessfulRemediations { get; set; }
    public int FailedRemediations { get; set; }
    public List<RemediationItem> Items { get; set; } = new();
}

public class RemediationItem
{
    public Vulnerability? Vulnerability { get; set; }
    public string PackageKey { get; set; } = string.Empty;
    public bool Success { get; set; }
    public string Status { get; set; } = string.Empty;
    public string? Error { get; set; }
    public string? Notes { get; set; }
    public string? GitHubIssueUrl { get; set; }
    public string? GitHubPullRequestUrl { get; set; }
    public string? BranchName { get; set; }
    public bool DependencyUpdateSuccess { get; set; }
    public bool BuildValidationSuccess { get; set; }
    public string? BuildErrorSummary { get; set; }
    public int CascadeUpdates { get; set; }
    public List<string> ReviewersRequested { get; set; } = new();
}
